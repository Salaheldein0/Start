<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Laundry Cycle Starter (Web Bluetooth)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    body { margin: 0; background: #0f172a; color: #e2e8f0; }
    .wrap { max-width: 760px; margin: 0 auto; padding: 20px; }
    h1 { font-size: 1.2rem; margin: 0 0 8px; }
    p { margin: 6px 0 14px; color: #cbd5e1; }
    .card { background: #111827; border: 1px solid #334155; border-radius: 14px; padding: 14px; margin: 12px 0; }
    .row { display: flex; flex-wrap: wrap; gap: 10px; }
    button {
      border: 1px solid #475569; background: #1e293b; color: #e2e8f0;
      padding: 10px 12px; border-radius: 10px; font-size: 0.95rem; cursor: pointer;
    }
    button:hover { background: #273449; }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    .ok { color: #22c55e; }
    .bad { color: #ef4444; }
    .warn { color: #f59e0b; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    #log {
      white-space: pre-wrap; background: #020617; border: 1px solid #334155;
      padding: 12px; border-radius: 10px; max-height: 340px; overflow: auto;
    }
    .small { font-size: 0.85rem; color: #94a3b8; }
    .pill { display: inline-block; border: 1px solid #475569; border-radius: 999px; padding: 2px 8px; margin-left: 6px; font-size: 12px; color: #93c5fd; }
    .map { margin-top: 8px; padding: 10px; border: 1px dashed #475569; border-radius: 10px; background: #0b1220; }
    .stage { margin-top: 8px; padding: 8px 10px; border-radius: 8px; background: #0b1220; border: 1px solid #334155; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Laundry Cycle Starter <span class="pill">Web Bluetooth</span></h1>
    <p>Make sure you are in the laundry room and Bluetooth is enabled.</p>

    <div class="card">
      <div class="row">
        <button id="connectBtn">Connect Device</button>
        <button id="disconnectBtn" disabled>Disconnect</button>
      </div>
      <p class="small" id="status">Status: not connected</p>

      <p class="small mono">
        RX UUID: 569a2000-b87f-490c-92cb-11ba5ea5167c<br>
        TX UUID: 569a2001-b87f-490c-92cb-11ba5ea5167c
      </p>

      <div class="map small">
        <strong>When selecting a device:</strong><br>
        Use <strong>Washer 1 (AWYDLOOBYZR1)</strong><br>
        Use <strong>Dryer 4</strong> for address <strong class="mono">30:30:f9:fe:4c:16</strong>
      </div>

      <div class="stage small" id="stage">Connection stage: idle</div>
      <p class="small" id="envNote"></p>
    </div>

    <div class="card">
      <div class="row">
        <button id="washerBtn" disabled>Washer 1 - Full wash</button>
        <button id="dryer15Btn" disabled>Dryer 4 - 15 min cycle</button>
        <button id="dryerFullBtn" disabled>Dryer 4 - Full dry</button>
      </div>
    </div>

    <div class="card">
      <strong>Log</strong>
      <div id="log" class="mono"></div>
    </div>
  </div>

  <script>
    // ===== Constants =====
    const RX_UUID = "569a2000-b87f-490c-92cb-11ba5ea5167c";
    const TX_UUID = "569a2001-b87f-490c-92cb-11ba5ea5167c";

    // Browser service permissions list.
    // NOTE: optionalServices expects service UUIDs. These are your known UUIDs from current setup.
    const OPTIONAL_SERVICE_UUIDS = [RX_UUID, TX_UUID];

    const DRYER4_ADDRESS = "30:30:f9:fe:4c:16";
    const WASHER1_ADV_NAME = "AWYDLOOBYZR1";

    const CMD = {
      HANDSHAKE: "[HANDSHAKE:ENABLE]",
      VERSION: "[VERSION]",
      COIN_DISABLE: "[COIN:DISABLE:OCCUPIED_LOW]",
      EXEC: "[EXEC]",
      ACTIVATE_WASHER_FULL: "[ACTIVATE:01:PULSE:OCCUPIED_LOW:00000000:00000032:00000032:0003:GZS979139]",
      ACTIVATE_DRYER_FULL:  "[ACTIVATE:01:PULSE:OCCUPIED_LOW:00000000:00000032:00000032:0004:CJS795938]",
      ACTIVATE_DRYER_15:    "[ACTIVATE:01:PULSE:OCCUPIED_LOW:00000000:00000032:00:0001:CJS795938]"
    };

    // ===== State =====
    let device = null;
    let server = null;
    let rxChar = null;
    let txChar = null;

    let rxBuf = new Uint8Array(0);
    const messageQueue = [];
    let waiters = [];

    const enc = new TextEncoder();
    const dec = new TextDecoder("utf-8", { fatal: false });

    // ===== UI =====
    const els = {
      connectBtn: document.getElementById("connectBtn"),
      disconnectBtn: document.getElementById("disconnectBtn"),
      washerBtn: document.getElementById("washerBtn"),
      dryer15Btn: document.getElementById("dryer15Btn"),
      dryerFullBtn: document.getElementById("dryerFullBtn"),
      status: document.getElementById("status"),
      log: document.getElementById("log"),
      envNote: document.getElementById("envNote"),
      stage: document.getElementById("stage"),
    };

    function setStage(text) {
      els.stage.textContent = `Connection stage: ${text}`;
    }

    function log(line, cls = "") {
      const ts = new Date().toLocaleTimeString();
      const text = `[${ts}] ${line}\n`;
      if (cls) {
        const span = document.createElement("span");
        span.className = cls;
        span.textContent = text;
        els.log.appendChild(span);
      } else {
        els.log.appendChild(document.createTextNode(text));
      }
      els.log.scrollTop = els.log.scrollHeight;
      console.log(line);
    }

    function setStatus(text, cls = "") {
      els.status.className = "small " + cls;
      els.status.textContent = "Status: " + text;
    }

    function setConnectedUi(connected) {
      els.connectBtn.disabled = connected;
      els.disconnectBtn.disabled = !connected;
      els.washerBtn.disabled = !connected;
      els.dryer15Btn.disabled = !connected;
      els.dryerFullBtn.disabled = !connected;
    }

    function resetRx() {
      rxBuf = new Uint8Array(0);
      messageQueue.length = 0;
      waiters.forEach(w => clearTimeout(w.timer));
      waiters = [];
    }

    function concatUint8(a, b) {
      const out = new Uint8Array(a.length + b.length);
      out.set(a, 0);
      out.set(b, a.length);
      return out;
    }

    function extractFramesFromBuffer() {
      const frames = [];
      while (true) {
        const start = rxBuf.indexOf("[".charCodeAt(0));
        if (start < 0) {
          rxBuf = new Uint8Array(0);
          return frames;
        }
        if (start > 0) rxBuf = rxBuf.slice(start);

        const end = rxBuf.indexOf("]".charCodeAt(0), 1);
        if (end < 0) return frames;

        frames.push(rxBuf.slice(0, end + 1));
        rxBuf = rxBuf.slice(end + 1);
      }
    }

    function onNotify(event) {
      try {
        const v = event.target.value;
        const chunk = new Uint8Array(v.buffer, v.byteOffset, v.byteLength);
        rxBuf = concatUint8(rxBuf, chunk);

        for (const raw of extractFramesFromBuffer()) {
          const msg = dec.decode(raw);
          log(`RX: ${msg}`);
          enqueueMessage(msg);
        }
      } catch (e) {
        log(`[WARN] Notify parse error: ${String(e)}`, "warn");
      }
    }

    function enqueueMessage(msg) {
      messageQueue.push(msg);
      resolveWaiters();
    }

    function resolveWaiters() {
      if (!waiters.length || !messageQueue.length) return;

      for (let i = 0; i < waiters.length; i++) {
        const w = waiters[i];
        const idx = messageQueue.findIndex(m => m.startsWith(w.prefix));
        if (idx >= 0) {
          const [msg] = messageQueue.splice(idx, 1);
          clearTimeout(w.timer);
          w.resolve(msg);
          waiters.splice(i, 1);
          i--;
        }
      }
    }

    function waitForPrefix(prefix, timeoutMs = 5000) {
      const immediateIdx = messageQueue.findIndex(m => m.startsWith(prefix));
      if (immediateIdx >= 0) {
        const [msg] = messageQueue.splice(immediateIdx, 1);
        return Promise.resolve(msg);
      }

      return new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
          const idx = waiters.findIndex(w => w.resolve === resolve);
          if (idx >= 0) waiters.splice(idx, 1);
          reject(new Error(`Timed out waiting for ${prefix}`));
        }, timeoutMs);

        waiters.push({ prefix, resolve, reject, timer });
      });
    }

    async function send(text, expectPrefix = null, timeoutMs = 5000) {
      if (!txChar) throw new Error("Not connected (TX missing)");

      log(`TX: ${text}`);
      const bytes = enc.encode(text);

      // Prefer no-response (your bleak behavior), fallback to with-response
      try {
        await txChar.writeValueWithoutResponse(bytes);
      } catch (e) {
        log("[WARN] writeValueWithoutResponse failed, retrying writeValue...", "warn");
        await txChar.writeValue(bytes);
      }

      if (expectPrefix) return await waitForPrefix(expectPrefix, timeoutMs);
      return "";
    }

    async function runSequence(activateCmd) {
      try {
        await send(CMD.HANDSHAKE, "[ACK:HANDSHAKE]", 8000);
        await send(CMD.VERSION, "[VERSION:", 8000);
        await send(CMD.COIN_DISABLE, "[ACK:COIN]", 8000);
        await send(activateCmd, "[ACK:ACTIVATE]", 8000);
        await send(CMD.EXEC, "[ACK:EXEC]", 8000);
        await new Promise(r => setTimeout(r, 500));
        log("Result: SUCCESS", "ok");
      } catch (e) {
        log(`[ERROR] ${String(e)}`, "bad");
        log("Result: FAILED", "bad");
      }
    }

    // TX is required; RX is optional (for notify)
    async function findRxTxCharacteristics(gattServer) {
      const rx = RX_UUID.toLowerCase();
      const tx = TX_UUID.toLowerCase();

      const services = await gattServer.getPrimaryServices();
      log(`[INFO] Found ${services.length} primary service(s).`);

      let foundRx = null, foundTx = null;

      for (const s of services) {
        let chars = [];
        try {
          chars = await s.getCharacteristics();
        } catch (e) {
          log(`[WARN] Could not read characteristics for service ${s.uuid}: ${String(e)}`, "warn");
          continue;
        }

        for (const c of chars) {
          const u = c.uuid.toLowerCase();
          if (u === rx) foundRx = c;
          if (u === tx) foundTx = c;
        }
      }

      if (!foundTx) {
        throw new Error(
          "TX characteristic not found. Wrong device or missing service permission (optionalServices)."
        );
      }

      return { foundRx, foundTx };
    }

    async function connect() {
      log("[INFO] Connect clicked...");
      setStage("start");

      if (!window.isSecureContext) {
        log("[ERROR] Web Bluetooth requires HTTPS or localhost.", "bad");
        setStatus("requires HTTPS/localhost", "bad");
        setStage("blocked: insecure context");
        return;
      }

      if (!navigator.bluetooth) {
        log("[ERROR] Web Bluetooth not supported in this browser.", "bad");
        setStatus("Web Bluetooth unsupported", "bad");
        setStage("blocked: unsupported browser");
        return;
      }

      // prevent rapid double-click race
      els.connectBtn.disabled = true;

      try {
        setStatus("opening chooser...");
        setStage("chooser");
        resetRx();

        const chosenDevice = await navigator.bluetooth.requestDevice({
          acceptAllDevices: true,
          optionalServices: OPTIONAL_SERVICE_UUIDS
        });

        log(`[INFO] Chooser returned: ${chosenDevice.name || "(unnamed)"} (${chosenDevice.id || "no-id"})`);
        device = chosenDevice;
        device.addEventListener("gattserverdisconnected", onDisconnected);

        setStatus("connecting GATT...");
        setStage("gatt connect");
        server = await device.gatt.connect();
        log("[INFO] GATT connected.", "ok");

        setStatus("discovering characteristics...");
        setStage("characteristic discovery");
        const { foundRx, foundTx } = await findRxTxCharacteristics(server);
        rxChar = foundRx;
        txChar = foundTx;

        // Enable buttons as soon as TX is ready
        setConnectedUi(true);
        setStatus(`connected to ${device.name || "(unnamed device)"}`, "ok");
        setStage("connected");
        log("[INFO] TX found. Controls enabled.", "ok");

        // Notifications are optional
        if (rxChar) {
          try {
            await rxChar.startNotifications();
            rxChar.addEventListener("characteristicvaluechanged", onNotify);
            log("[INFO] RX notifications started.", "ok");
          } catch (e) {
            log(`[WARN] RX exists but notifications failed: ${String(e)}`, "warn");
          }
        } else {
          log("[WARN] RX characteristic not found; continuing without notifications.", "warn");
        }

        if ((device.name || "") === WASHER1_ADV_NAME) {
          log("[INFO] Selected device matches Washer 1 (AWYDLOOBYZR1).", "ok");
        } else {
          log("[INFO] If this is Dryer 4, continue. If not, disconnect and choose again.", "warn");
        }

      } catch (e) {
        const msg = `${e?.name || "Error"}: ${e?.message || String(e)}`;
        log(`[ERROR] Connect failed: ${msg}`, "bad");
        setStatus("connect failed", "bad");

        if (e?.name === "NotFoundError") {
          log("[HINT] Chooser closed without returning a device. Click a device then Pair/Connect.", "warn");
          setStage("chooser cancelled/no device");
        } else if (e?.name === "SecurityError") {
          log("[HINT] Need correct service UUID(s) in optionalServices for this device.", "warn");
          setStage("security error");
        } else {
          setStage("failed");
        }

        await disconnect();
      } finally {
        // If not connected, re-enable connect button
        if (!device || !device.gatt || !device.gatt.connected) {
          els.connectBtn.disabled = false;
        }
      }
    }

    async function disconnect() {
      try {
        if (rxChar) {
          try {
            rxChar.removeEventListener("characteristicvaluechanged", onNotify);
            await rxChar.stopNotifications();
          } catch (e) {
            log(`[WARN] stopNotifications issue: ${String(e)}`, "warn");
          }
        }

        if (device && device.gatt && device.gatt.connected) {
          device.gatt.disconnect();
        }
      } finally {
        device = null;
        server = null;
        rxChar = null;
        txChar = null;
        resetRx();
        setConnectedUi(false);
        setStatus("not connected");
        setStage("idle");
        log("[INFO] Disconnected.");
      }
    }

    function onDisconnected() {
      log("[WARN] Device disconnected.", "warn");
      device = null;
      server = null;
      rxChar = null;
      txChar = null;
      resetRx();
      setConnectedUi(false);
      setStatus("disconnected", "warn");
      setStage("disconnected");
      els.connectBtn.disabled = false;
    }

    // ===== UI events =====
    els.connectBtn.addEventListener("click", connect);
    els.disconnectBtn.addEventListener("click", disconnect);

    els.washerBtn.addEventListener("click", async () => {
      log("Starting Washer 1: Full wash...");
      await runSequence(CMD.ACTIVATE_WASHER_FULL);
    });

    els.dryer15Btn.addEventListener("click", async () => {
      log("Starting Dryer 4: 15 min cycle...");
      await runSequence(CMD.ACTIVATE_DRYER_15);
    });

    els.dryerFullBtn.addEventListener("click", async () => {
      log("Starting Dryer 4: Full dry cycle...");
      await runSequence(CMD.ACTIVATE_DRYER_FULL);
    });

    // Init
    setConnectedUi(false);
    setStage("idle");
    log(`Use Washer 1 (${WASHER1_ADV_NAME})`);
    log(`Use Dryer 4 for address ${DRYER4_ADDRESS}`);

    const ua = navigator.userAgent || "";
    const isFirefox = ua.toLowerCase().includes("firefox");
    if (isFirefox) {
      els.envNote.textContent = "You appear to be on Firefox. Web Bluetooth is typically unavailable there; use Chrome/Edge.";
      log("[WARN] Firefox detected. Use Chrome/Edge for Web Bluetooth.", "warn");
    } else if (!window.isSecureContext) {
      els.envNote.textContent = "This page must be served over HTTPS (or localhost) for Web Bluetooth.";
      log("[WARN] Insecure context detected. Use HTTPS or localhost.", "warn");
    } else {
      els.envNote.textContent = "";
    }

    // Extra diagnostics to avoid silent failures
    window.addEventListener("error", (e) => {
      log(`[ERROR] Uncaught: ${e.message}`, "bad");
    });
    window.addEventListener("unhandledrejection", (e) => {
      log(`[ERROR] Promise rejection: ${String(e.reason)}`, "bad");
    });
  </script>
</body>
</html>
